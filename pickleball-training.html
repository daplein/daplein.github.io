<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pickleball Training Schedule</title>
    <script src="./libs/pako.min.js"></script>
    <script src="./libs/tailwind.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        .container {
            max-width: 100%;
        }
        @media (min-width: 768px) {
            .container {
                max-width: 800px;
            }
        }
        .tab-button.active {
            border-bottom: 3px solid #3b82f6;
            color: #3b82f6;
            font-weight: 600;
        }
        .tab-content.hidden {
            display: none;
        }
        /* Add a minimum height to prevent layout shift */
        .tab-content {
            min-height: 400px;
        }

        /* Responsive table styles for mobile */
        .responsive-table {
            border-collapse: collapse;
            width: 100%; /* Ensure table takes full width */
        }
        
        @media (max-width: 767px) {
            .responsive-table thead {
                display: none;
            }
            .responsive-table tr {
                display: block;
                margin-bottom: 1rem;
                border: 1px solid #e5e7eb;
                border-radius: 0.5rem;
                padding: 1rem;
            }
            .responsive-table td {
                display: block;
                text-align: right;
                font-size: 0.875rem;
                position: relative;
                padding-left: 50%;
                border: none;
            }
            .responsive-table td::before {
                content: attr(data-label);
                position: absolute;
                left: 1rem;
                width: calc(50% - 1.5rem);
                font-weight: 600;
                text-align: left;
            }
            .responsive-table td:first-child {
                border-top-left-radius: 0.5rem;
                border-top-right-radius: 0.5rem;
            }
            .responsive-table td:last-child {
                border-bottom-left-radius: 0.5rem;
                border-bottom-right-radius: 0.5rem;
            }
        }
        /* Style for editable name field */
        .editable-name:focus {
            outline: 2px solid #3b82f6;
            border-radius: 0.25rem;
            background-color: #e3f2fd;
        }
        .court-cell {
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border-radius: 0.5rem;
        }
        .court-cell.played {
            background-color: #d1fae5; /* Green color for played matches */
        }

        /* Sortable header styling */
        .sortable {
            cursor: pointer;
            position: relative;
        }
        .sortable:hover {
            color: #3b82f6;
        }
        .sort-icon {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .sortable:hover .sort-icon {
            opacity: 1;
        }
        .sort-icon.asc::before {
            content: "▲";
        }
        .sort-icon.desc::before {
            content: "▼";
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center">

    <div class="container mx-auto p-0 bg-white rounded-none md:rounded-xl shadow-lg w-full">
        <div class="p-4 md:p-6">
            <h1 class="text-3xl font-bold text-center mb-6 text-gray-800">Pickleball Training Schedule</h1>
        
            <!-- Tab Buttons -->
            <div class="flex border-b border-gray-200 mb-6">
                <button id="playersTabBtn" class="tab-button active flex-1 py-3 px-4 text-center text-gray-600 hover:text-blue-500 transition-colors duration-200 focus:outline-none">
                    Players
                </button>
                <button id="scheduleTabBtn" class="tab-button flex-1 py-3 px-4 text-center text-gray-600 hover:text-blue-500 transition-colors duration-200 focus:outline-none">
                    Schedule
                </button>
            </div>

            <!-- Players Tab Content -->
            <div id="playersTabContent" class="tab-content">
                <!-- Settings & Player Input Section -->
                <div class="mb-6 bg-gray-50 p-4 rounded-lg">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-700">Settings</h2>
                    <div class="flex flex-col md:flex-row md:items-center gap-4 mb-4">
                        <div class="flex items-center gap-2">
                            <label for="numCourts" class="font-medium text-gray-700">Number of Courts:</label>
                            <input type="number" id="numCourts" value="2" min="1" max="4" class="w-24 p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div class="flex items-center gap-2">
                            <label for="startTime" class="font-medium text-gray-700">Starting Time:</label>
                            <input type="time" id="startTime" value="18:30" class="w-32 p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div class="flex items-center gap-2">
                            <label for="endTime" class="font-medium text-gray-700">Ending Time:</label>
                            <input type="time" id="endTime" value="20:00" class="w-32 p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus-ring-blue-500">
                        </div>
                    </div>
                    <!-- New option for team balancing -->
                    <div class="flex items-center gap-2 mb-4">
                        <input type="checkbox" id="balancedTeams" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                        <label for="balancedTeams" class="font-medium text-gray-700">Prevent Level 2 players from teaming up</label>
                    </div>
                    <h2 class="text-2xl font-semibold mb-4 text-gray-700 mt-6">Add Players</h2>
                    <div class="flex flex-col md:flex-row gap-4 mb-4 items-center">
                        <input type="text" id="playerName" placeholder="Enter player name" class="flex-1 p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="addPlayerBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">
                            Add Player
                        </button>
                    </div>
                </div>

                <!-- Player List & Generate Button -->
                <div class="mb-8">
                    <div class="flex flex-col sm:flex-row justify-between items-center gap-4 mb-4">
                        <h2 class="text-2xl font-semibold text-gray-700">Players</h2>
                        <div class="flex gap-2 w-full sm:w-auto">
                            <button id="resetBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 w-1/2 sm:w-auto">
                                Reset
                            </button>
                            <button id="randomPlayersBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 w-1/2 sm:w-auto">
                                Random
                            </button>
                            <button id="generateScheduleBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 w-full sm:w-auto">
                                Generate Schedule
                            </button>
                        </div>
                    </div>
                    <div id="messageArea" class="text-red-500 font-semibold mb-4 text-center"></div>
                    <div class="overflow-x-auto">
                        <table class="w-full table-auto border-collapse responsive-table">
                            <thead class="bg-gray-200">
                                <tr class="rounded-lg">
                                    <th class="px-4 py-2 text-left text-gray-600 rounded-tl-lg">No.</th>
                                    <th class="px-4 py-2 text-left text-gray-600 sortable" data-sort-by="name">
                                        Player Name
                                        <span class="sort-icon"></span>
                                    </th>
                                    <th class="px-4 py-2 text-left text-gray-600 sortable" data-sort-by="level">
                                        Skill Level
                                        <span class="sort-icon"></span>
                                    </th>
                                    <th class="px-4 py-2 text-left text-gray-600 sortable" data-sort-by="startTime">
                                        Start Time
                                        <span class="sort-icon"></span>
                                    </th>
                                    <th class="px-4 py-2 text-left text-gray-600 sortable" data-sort-by="endTime">
                                        End Time
                                        <span class="sort-icon"></span>
                                    </th>
                                    <th class="px-4 py-2 text-left text-gray-600 sortable" data-sort-by="playCount">
                                        Play Periods
                                        <span class="sort-icon"></span>
                                    </th>
                                    <th class="px-4 py-2 text-left text-gray-600 sortable" data-sort-by="restCount">
                                        Rest Periods
                                        <span class="sort-icon"></span>
                                    </th>
                                    <th class="px-4 py-2 text-left text-gray-600 sortable" data-sort-by="wins">
                                        Wins
                                        <span class="sort-icon"></span>
                                    </th>
                                    <th class="px-4 py-2 text-left text-gray-600 rounded-tr-lg">Action</th>
                                </tr>
                            </thead>
                            <tbody id="playerTableBody" class="divide-y divide-gray-200">
                                <!-- Player rows will be generated here by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Schedule Tab Content -->
            <div id="scheduleTabContent" class="tab-content hidden">
                <!-- Combined heading and share URL section -->
                <div class="flex flex-col md:flex-row md:items-center justify-between mb-4">
                    <h2 class="text-2xl font-semibold text-gray-700 mb-2 md:mb-0">Training Schedule</h2>
                    <div class="flex flex-col sm:flex-row gap-2 w-full md:w-auto mt-2 md:mt-0">
                        <input type="hidden" id="shareUrlInput">
                        <button id="copyUrlBtn" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-md transition-colors duration-200 flex-shrink-0">
                            Share Schedule
                        </button>
                    </div>
                </div>

                <!-- Notification Popup -->
                <div id="notificationPopup" class="fixed bottom-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg transform translate-y-full opacity-0 transition-all duration-300 ease-in-out">
                    <div class="flex items-center space-x-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                        </svg>
                        <p>The URL has been copied to your clipboard. It contains all the player and schedule information.</p>
                    </div>
                </div>

                <div id="scheduleTableContainer" class="overflow-x-auto">
                    <table class="w-full table-auto border-collapse responsive-table">
                        <thead class="bg-gray-200" id="scheduleTableHeader">
                            <!-- Header will be dynamically generated -->
                        </thead>
                        <tbody id="scheduleTableBody" class="divide-y divide-gray-200">
                            <!-- Schedule rows will be generated here by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let players = [];
            let scheduleData = [];
            let sortDirection = {}; // To store the sort direction for each column
            
            // Get default start and end times from main settings
            const defaultStartTime = document.getElementById('startTime').value;
            const defaultEndTime = document.getElementById('endTime').value;

            // List of random names for the "Random" button
            const randomNames = ["Alice", "Bob", "Charlie", "Diana", "Ethan", "Fiona", "George", "Hannah", "Isaac", "Jasmine", "Kevin", "Laura", "Mike", "Nora", "Oscar", "Penny", "Quinn", "Rachel", "Sam", "Tina"];

            // DOM elements
            const playersTabBtn = document.getElementById('playersTabBtn');
            const scheduleTabBtn = document.getElementById('scheduleTabBtn');
            const playersTabContent = document.getElementById('playersTabContent');
            const scheduleTabContent = document.getElementById('scheduleTabContent');
            const addPlayerBtn = document.getElementById('addPlayerBtn');
            const playerNameInput = document.getElementById('playerName');
            const playerTableBody = document.getElementById('playerTableBody');
            const generateScheduleBtn = document.getElementById('generateScheduleBtn');
            const scheduleTableBody = document.getElementById('scheduleTableBody');
            const scheduleTableHeader = document.getElementById('scheduleTableHeader');
            const numCourtsInput = document.getElementById('numCourts');
            const startTimeInput = document.getElementById('startTime');
            const endTimeInput = document.getElementById('endTime');
            const messageArea = document.getElementById('messageArea');
            const shareUrlInput = document.getElementById('shareUrlInput');
            const copyUrlBtn = document.getElementById('copyUrlBtn');
            const copyMessage = document.getElementById('copyMessage');
            const playerTableHead = document.querySelector('#playersTabContent thead');
            const balancedTeamsCheckbox = document.getElementById('balancedTeams');
            const resetBtn = document.getElementById('resetBtn');
            const randomPlayersBtn = document.getElementById('randomPlayersBtn');

            // Tab functionality
            function showTab(tabName) {
                // Hide all tab contents
                playersTabContent.classList.add('hidden');
                scheduleTabContent.classList.add('hidden');

                // Deactivate all tab buttons
                playersTabBtn.classList.remove('active');
                scheduleTabBtn.classList.remove('active');

                // Show the selected tab and activate its button
                if (tabName === 'players') {
                    playersTabContent.classList.remove('hidden');
                    playersTabBtn.classList.add('active');
                } else if (tabName === 'schedule') {
                    playersTabBtn.classList.remove('active');
                    scheduleTabContent.classList.remove('hidden');
                    scheduleTabBtn.classList.add('active');
                }
            }
            
            playersTabBtn.addEventListener('click', () => showTab('players'));
            scheduleTabBtn.addEventListener('click', () => showTab('schedule'));

            // Function to update the shareable URL based on the current state
            const updateUrlWithCurrentState = () => {
                try {
                    const shareablePlayers = players.map(p => ({
                        n: p.name,
                        l: p.level,
                        st: p.startTime,
                        et: p.endTime,
                        w: p.wins // Include wins in the shareable data
                    }));
                    const playerJson = JSON.stringify(shareablePlayers);
                    const scheduleJson = JSON.stringify(scheduleData);

                    // Corrected compression and encoding to handle binary data
                    const compressedPlayers = pako.deflate(playerJson);
                    const encodedPlayers = btoa(String.fromCharCode.apply(null, compressedPlayers));
                    
                    const compressedSchedule = pako.deflate(scheduleJson);
                    const encodedSchedule = btoa(String.fromCharCode.apply(null, compressedSchedule));
                    
                    const params = new URLSearchParams();
                    params.set('p', encodedPlayers);
                    params.set('s', encodedSchedule);
                    params.set('c', numCourtsInput.value);
                    params.set('st', startTimeInput.value);
                    params.set('et', endTimeInput.value);
                    // Add the new parameter for balanced teams
                    params.set('bt', balancedTeamsCheckbox.checked ? 'true' : 'false');
                    const newUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
                    shareUrlInput.value = newUrl;
                    
                    // Update the browser's URL without reloading the page
                    try {
                        window.history.pushState({}, '', newUrl);
                    } catch (e) {
                        console.error('Failed to update browser history:', e);
                    }
                } catch (e) {
                    console.error('Error generating shareable URL:', e);
                }
            };

            // Function to add a player
            const addPlayer = (name) => {
                const defaultStartTime = startTimeInput.value;
                const defaultEndTime = endTimeInput.value;
                if (name) {
                    players.push({ name, level: 1, startTime: defaultStartTime, endTime: defaultEndTime, restCount: 0, playCount: 0, wins: 0 });
                    playerNameInput.value = '';
                    renderPlayers();
                    updateUrlWithCurrentState(); // Update URL after adding a player
                }
            };

            // Add player functionality
            addPlayerBtn.addEventListener('click', () => {
                addPlayer(playerNameInput.value.trim());
            });

            // Add player on Enter key press in the input field
            playerNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent form submission
                    addPlayer(playerNameInput.value.trim());
                }
            });
            
            // Function to calculate and update player stats
            const calculatePlayerStats = () => {
                // Reset stats
                players.forEach(p => {
                    p.wins = 0;
                });

                scheduleData.forEach(round => {
                    round.courts.forEach(court => {
                        const [teamA, teamB, played, scoreA, scoreB] = court;
                        if (played && scoreA !== null && scoreB !== null) {
                            if (scoreA > scoreB) {
                                // Team A won
                                teamA.forEach(playerName => {
                                    const player = players.find(p => p.name === playerName);
                                    if (player) {
                                        player.wins++;
                                    }
                                });
                            } else if (scoreB > scoreA) {
                                // Team B won
                                teamB.forEach(playerName => {
                                    const player = players.find(p => p.name === playerName);
                                    if (player) {
                                        player.wins++;
                                    }
                                });
                            }
                        }
                    });
                });
                renderPlayers();
            };

            // Function to handle table sorting
            const sortPlayers = (column) => {
                // Toggle sort direction
                if (sortDirection[column] === 'asc') {
                    sortDirection[column] = 'desc';
                } else {
                    sortDirection[column] = 'asc';
                }

                // Remove sort icons from all headers
                document.querySelectorAll('.sort-icon').forEach(icon => {
                    icon.classList.remove('asc', 'desc');
                });
                
                // Add the new sort icon to the current header
                const header = document.querySelector(`th[data-sort-by="${column}"] .sort-icon`);
                if (header) {
                    header.classList.add(sortDirection[column]);
                }

                // Sort the players array
                players.sort((a, b) => {
                    const aValue = a[column];
                    const bValue = b[column];

                    if (typeof aValue === 'string') {
                        return sortDirection[column] === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                    } else {
                        return sortDirection[column] === 'asc' ? aValue - bValue : bValue - aValue;
                    }
                });
                
                renderPlayers();
            };

            // Event listener for sortable headers
            playerTableHead.addEventListener('click', (e) => {
                const header = e.target.closest('th.sortable');
                if (header) {
                    const sortBy = header.getAttribute('data-sort-by');
                    if (sortBy) {
                        sortPlayers(sortBy);
                    }
                }
            });

            // Function to render the player list in the table
            const renderPlayers = () => {
                playerTableBody.innerHTML = '';
                // Use the players array directly, as it is now sorted
                players.forEach((player, index) => {
                    const row = document.createElement('tr');
                    // Use a data attribute with the player's name for robust identification
                    row.setAttribute('data-player-name', player.name);
                    row.innerHTML = `
                        <td class="px-4 py-2" data-label="No.">${index + 1}</td>
                        <td class="px-4 py-2" data-label="Player Name">
                            <span contenteditable="true" class="editable-name" data-player-name="${player.name}">${player.name}</span>
                        </td>
                        <td class="px-4 py-2" data-label="Skill Level">
                            <select class="player-level-select p-1 border border-gray-300 rounded-md" data-player-name="${player.name}">
                                <option value="1" ${player.level === 1 ? 'selected' : ''}>Level 1</option>
                                <option value="2" ${player.level === 2 ? 'selected' : ''}>Level 2</option>
                            </select>
                        </td>
                        <td class="px-4 py-2" data-label="Start Time">
                            <input type="time" class="player-start-time-input p-1 border border-gray-300 rounded-md" data-player-name="${player.name}" value="${player.startTime}">
                        </td>
                        <td class="px-4 py-2" data-label="End Time">
                            <input type="time" class="player-end-time-input p-1 border border-gray-300 rounded-md" data-player-name="${player.name}" value="${player.endTime}">
                        </td>
                        <td class="px-4 py-2 font-bold" data-label="Play Periods">${player.playCount}</td>
                        <td class="px-4 py-2 font-bold" data-label="Rest Periods">${player.restCount}</td>
                        <td class="px-4 py-2 font-bold" data-label="Wins">${player.wins}</td>
                        <td class="px-4 py-2" data-label="Action">
                            <button class="remove-player-btn bg-red-500 hover:bg-red-600 text-white py-1 px-2 rounded-md transition-colors duration-200" data-player-name="${player.name}">Remove</button>
                        </td>
                    `;
                    playerTableBody.appendChild(row);
                });
            };

            // Find a player object by name
            const findPlayerByName = (name) => {
                return players.find(p => p.name === name);
            };

            // Remove a player from the list
            playerTableBody.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-player-btn')) {
                    const playerName = e.target.getAttribute('data-player-name');
                    players = players.filter(p => p.name !== playerName);
                    renderPlayers();
                    updateUrlWithCurrentState(); // Update URL after removing a player
                }
            });

            // Update player level or availability times when a dropdown or input changes
            playerTableBody.addEventListener('change', (e) => {
                const target = e.target;
                const playerName = target.getAttribute('data-player-name');
                const player = findPlayerByName(playerName);
                if (player) {
                    if (target.classList.contains('player-level-select')) {
                        player.level = parseInt(target.value);
                    } else if (target.classList.contains('player-start-time-input')) {
                        player.startTime = target.value;
                    } else if (target.classList.contains('player-end-time-input')) {
                        player.endTime = target.value;
                    }
                    updateUrlWithCurrentState(); // Update URL after any player detail changes
                }
            });

            // Add an event listener to update player name on blur (when the user clicks away)
            playerTableBody.addEventListener('blur', (e) => {
                const target = e.target;
                if (target.classList.contains('editable-name')) {
                    const oldName = target.getAttribute('data-player-name');
                    const newName = target.textContent.trim();
                    const player = findPlayerByName(oldName);
                    if (player) {
                        player.name = newName;
                        target.setAttribute('data-player-name', newName); // Update the data attribute
                        // Also update the data attributes on sibling elements in the same row
                        const row = target.closest('tr');
                        row.querySelectorAll('[data-player-name]').forEach(el => el.setAttribute('data-player-name', newName));
                        updateUrlWithCurrentState();
                    }
                }
            }, true); // Use capture phase to catch the event before other listeners

            // Sync all players' start times with the main start time
            startTimeInput.addEventListener('change', (e) => {
                const newStartTime = e.target.value;
                players.forEach(p => p.startTime = newStartTime);
                renderPlayers();
                updateUrlWithCurrentState(); // Update URL when global start time changes
            });

            // Sync all players' end times with the main end time
            endTimeInput.addEventListener('change', (e) => {
                const newEndTime = e.target.value;
                players.forEach(p => p.endTime = newEndTime);
                renderPlayers();
                updateUrlWithCurrentState(); // Update URL when global end time changes
            });

            // Helper function to convert "HH:MM" to minutes from midnight
            const timeToMinutes = (timeString) => {
                const [hours, minutes] = timeString.split(':').map(Number);
                return hours * 60 + minutes;
            };

            // Helper function to render a schedule object into the HTML table
            const renderSchedule = (numCourts) => {
                scheduleTableBody.innerHTML = '';
                // Generate table headers based on the number of courts
                let headerHtml = `<tr class="rounded-lg">
                                    <th class="px-4 py-2 text-left text-gray-600 rounded-tl-lg">Round</th>
                                    <th class="px-4 py-2 text-left text-gray-600">Time Slot</th>
                                    <th class="px-4 py-2 text-left text-gray-600">Available Players</th>`;
                for (let i = 1; i <= numCourts; i++) {
                    headerHtml += `<th class="px-4 py-2 text-left text-gray-600">Court ${i}</th>`;
                }
                headerHtml += `<th class="px-4 py-2 text-left text-gray-600 rounded-tr-lg">Resting Players</th>`;
                headerHtml += `</tr>`;
                scheduleTableHeader.innerHTML = headerHtml;

                // Populate table rows with schedule data
                scheduleData.forEach((roundData, roundIndex) => {
                    const row = document.createElement('tr');
                    const courtData = roundData.courts.map((court, courtIndex) => {
                        const [teamA, teamB, played, scoreA, scoreB] = court;
                        const scoreAValue = scoreA !== null ? scoreA : '';
                        const scoreBValue = scoreB !== null ? scoreB : '';
                        
                        return `<td class="px-2 py-2" data-label="Court ${courtIndex + 1}">
                                <div class="court-cell cursor-pointer rounded-lg p-2 transition-colors duration-200 ${played ? 'bg-green-200' : 'bg-gray-100'}" data-round-index="${roundIndex}" data-court-index="${courtIndex}">
                                    <div class="flex flex-col items-center">
                                        <span>${teamA.join(' & ')}</span>
                                        <div class="flex items-center gap-1 my-1">
                                            <input type="number" class="score-input w-10 text-center border rounded-md focus:outline-none focus:ring-1 focus:ring-blue-500" value="${scoreAValue}" min="0">
                                            <span class="text-sm font-semibold text-gray-500">-</span>
                                            <input type="number" class="score-input w-10 text-center border rounded-md focus:outline-none focus:ring-1 focus:ring-blue-500" value="${scoreBValue}" min="0">
                                        </div>
                                        <span>${teamB.join(' & ')}</span>
                                    </div>
                                </div>
                            </td>`;
                    }).join('');
                    
                    const restingTeamDisplay = roundData.resting.length > 0 ? roundData.resting.join(', ') : '---';

                    row.innerHTML = `
                        <td class="px-4 py-2" data-label="Round">${roundIndex + 1}</td>
                        <td class="px-4 py-2" data-label="Time Slot">${roundData.time}</td>
                        <td class="px-4 py-2" data-label="Available Players">${roundData.playingCount} / ${players.length}</td>
                        ${courtData}
                        <td class="px-4 py-2" data-label="Resting Players">${restingTeamDisplay}</td>
                    `;
                    scheduleTableBody.appendChild(row);
                });
            }

            // Function to shuffle an array
            const shuffleArray = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            };
            
            // Function to generate and display the schedule
            const generateAndDisplaySchedule = () => {
                // Reset play and rest counts for a new schedule
                players.forEach(p => {
                    p.restCount = 0;
                    p.playCount = 0;
                    p.wins = 0; // Reset wins on new schedule generation
                });
                renderPlayers();

                messageArea.textContent = '';
                scheduleTableBody.innerHTML = '';

                // Get settings from input fields
                const numCourts = parseInt(numCourtsInput.value);
                const roundDurationMinutes = 10;
                const startTimeValue = startTimeInput.value;
                const endTimeValue = endTimeInput.value;
                const startMinutes = timeToMinutes(startTimeValue);
                const endMinutes = timeToMinutes(endTimeValue);
                const useBalancedTeams = balancedTeamsCheckbox.checked;

                // Validation Checks
                if (players.length < numCourts * 4) {
                    messageArea.textContent = `You need at least ${numCourts * 4} players for ${numCourts} courts.`;
                    return;
                }
                
                // Calculate number of rounds based on start and end times
                if (endMinutes <= startMinutes) {
                    messageArea.textContent = 'End time must be after start time.';
                    return;
                }
                const totalDurationMinutes = endMinutes - startMinutes;
                const numRounds = Math.floor(totalDurationMinutes / roundDurationMinutes);
                
                // Create a balanced schedule
                let currentMinutes = startMinutes;
                scheduleData = [];

                for (let round = 0; round < numRounds; round++) {
                    const currentHour = Math.floor(currentMinutes / 60);
                    const currentMinute = currentMinutes % 60;
                    const timeString = `${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}`;
                    
                    // Filter players who are available during this time slot
                    const availablePlayers = players.filter(p => {
                        const playerStartMinutes = timeToMinutes(p.startTime);
                        const playerEndMinutes = timeToMinutes(p.endTime);
                        return currentMinutes >= playerStartMinutes && currentMinutes < playerEndMinutes;
                    });
                    
                    // Sort available players by play count (ascending) to prioritize playing for those who played least
                    availablePlayers.sort((a, b) => a.playCount - b.playCount);
                    
                    const playersToPlay = availablePlayers.slice(0, numCourts * 4);
                    const restingPlayers = availablePlayers.slice(numCourts * 4);
                    
                    const roundData = {
                        time: timeString,
                        courts: [],
                        resting: restingPlayers.map(p => p.name),
                        playingCount: playersToPlay.length
                    };
                    
                    const teams = [];
                    let remainingPlayers = [...playersToPlay];

                    if (useBalancedTeams) {
                        const level1Players = remainingPlayers.filter(p => p.level === 1);
                        const level2Players = remainingPlayers.filter(p => p.level === 2);
                        
                        // Form mixed-level teams first
                        while (level1Players.length > 0 && level2Players.length > 0) {
                            const team = [level2Players.shift(), level1Players.shift()];
                            teams.push(team);
                        }
                        
                        // Form teams from remaining players of the same level
                        while (level1Players.length >= 2) {
                            const team = [level1Players.shift(), level1Players.shift()];
                            teams.push(team);
                        }
                        while (level2Players.length >= 2) {
                            const team = [level2Players.shift(), level2Players.shift()];
                            teams.push(team);
                        }
                        remainingPlayers = [...level1Players, ...level2Players]; // These players will be resting
                    } else {
                        // If balanced teams are not required, just form teams from the list
                        while (remainingPlayers.length >= 2) {
                            const team = [remainingPlayers.shift(), remainingPlayers.shift()];
                            teams.push(team);
                        }
                    }

                    shuffleArray(teams); // Shuffle teams to mix up opponents

                    // Assign teams to courts
                    for (let i = 0; i < numCourts && teams.length >= 2; i++) {
                        const teamA = teams.shift();
                        const teamB = teams.shift();
                        roundData.courts.push([teamA.map(p => p.name), teamB.map(p => p.name), false, null, null]);
                        
                        // Update play counts for the players who just played
                        teamA.forEach(p => p.playCount++);
                        teamB.forEach(p => p.playCount++);
                    }
                    
                    // Update rest counts for all available players who did not get to play
                    const playersWhoPlayed = roundData.courts.flat().flat();
                    playersToPlay.forEach(p => {
                        if (!playersWhoPlayed.includes(p.name)) {
                           p.restCount++;
                        }
                    });

                    scheduleData.push(roundData);
                    currentMinutes += roundDurationMinutes;
                }

                // Update the player table to show rest and play counts
                renderPlayers();
                
                // Render the generated schedule
                renderSchedule(numCourts);

                // Update the URL with the new schedule data
                updateUrlWithCurrentState();

                // After generating, switch to the schedule view
                showTab('schedule');
            };

            // Function to generate a random list of players
            const generateRandomPlayers = () => {
                // Randomly set number of courts (1-4)
                const randomCourts = Math.floor(Math.random() * 4) + 1;
                numCourtsInput.value = randomCourts;

                // Set a minimum number of players based on the courts selected
                const minPlayers = randomCourts * 4;
                const maxPlayers = 20; // A reasonable upper limit
                const numPlayers = Math.floor(Math.random() * (maxPlayers - minPlayers + 1)) + minPlayers;
                
                // Randomly set start and end times
                const startHour = Math.floor(Math.random() * 10) + 10; // 10 to 19 (10am to 7pm)
                const startMinute = Math.floor(Math.random() * 4) * 15; // 0, 15, 30, 45
                const sessionDuration = Math.floor(Math.random() * 3) + 1; // 1, 2, or 3 hours
                
                const startTime = `${String(startHour).padStart(2, '0')}:${String(startMinute).padStart(2, '0')}`;
                
                const endMinutes = timeToMinutes(startTime) + (sessionDuration * 60);
                const endHour = Math.floor(endMinutes / 60);
                const endMinute = endMinutes % 60;
                const endTime = `${String(endHour).padStart(2, '0')}:${String(endMinute).padStart(2, '0')}`;

                startTimeInput.value = startTime;
                endTimeInput.value = endTime;
                
                // Generate players
                const newPlayers = [];
                const usedNames = new Set();
                
                while (newPlayers.length < numPlayers) {
                    const randomName = randomNames[Math.floor(Math.random() * randomNames.length)];
                    if (!usedNames.has(randomName)) {
                        newPlayers.push({
                            name: randomName,
                            level: 1,
                            startTime,
                            endTime,
                            restCount: 0,
                            playCount: 0,
                            wins: 0
                        });
                        usedNames.add(randomName);
                    }
                }
                players = newPlayers;
                renderPlayers();
                updateUrlWithCurrentState();
                messageArea.textContent = '';
                showTab('players');
            };

            // Function to reset the application to its initial state
            const resetApplicationState = () => {
                players = [];
                scheduleData = [];
                renderPlayers();
                renderSchedule(parseInt(numCourtsInput.value));
                shareUrlInput.value = '';
                // Clear URL parameters
                window.history.pushState({}, '', window.location.pathname);
                messageArea.textContent = '';
                showTab('players');
            };

            // Function to load state from URL on page load
            const loadStateFromUrl = () => {
                const params = new URLSearchParams(window.location.search);
                const playersParam = params.get('p');
                const scheduleParam = params.get('s');
                const courtsParam = params.get('c');
                const startTimeParam = params.get('st');
                const endTimeParam = params.get('et');
                const balancedTeamsParam = params.get('bt');
                
                let scheduleLoaded = false;

                if (playersParam) {
                    try {
                        const decodedPlayers = atob(playersParam);
                        const playerCharCodes = new Uint8Array(decodedPlayers.length);
                        for (let i = 0; i < decodedPlayers.length; i++) {
                            playerCharCodes[i] = decodedPlayers.charCodeAt(i);
                        }
                        const decompressedPlayers = pako.inflate(playerCharCodes, { to: 'string' });
                        const parsedPlayers = JSON.parse(decompressedPlayers);

                        players = parsedPlayers.map(p => ({
                            name: p.n,
                            level: p.l,
                            startTime: p.st,
                            endTime: p.et,
                            restCount: 0, // Reset these as they are recalculated
                            playCount: 0, // Reset these as they are recalculated
                            wins: p.w || 0 // Load wins from URL or default to 0
                        }));
                        
                        if (courtsParam) numCourtsInput.value = courtsParam;
                        if (startTimeParam) startTimeInput.value = startTimeParam;
                        if (endTimeParam) endTimeInput.value = endTimeParam;
                        if (balancedTeamsParam) balancedTeamsCheckbox.checked = balancedTeamsParam === 'true';

                        if (scheduleParam) {
                             try {
                                const decodedSchedule = atob(scheduleParam);
                                const scheduleCharCodes = new Uint8Array(decodedSchedule.length);
                                for (let i = 0; i < decodedSchedule.length; i++) {
                                    scheduleCharCodes[i] = decodedSchedule.charCodeAt(i);
                                }
                                const decompressedSchedule = pako.inflate(scheduleCharCodes, { to: 'string' });
                                scheduleData = JSON.parse(decompressedSchedule);
                                
                                // Recalculate player play and rest counts from the loaded schedule
                                players.forEach(p => {
                                    p.restCount = 0;
                                    p.playCount = 0;
                                });
                                scheduleData.forEach(round => {
                                    round.courts.forEach(court => {
                                        if (court.length > 0 && court[0].length > 0) { 
                                            // Update play counts for Team A and Team B
                                            court[0].forEach(name => {
                                                const player = findPlayerByName(name);
                                                if (player) player.playCount++;
                                            });
                                            if (court[1] && court[1].length > 0) {
                                                court[1].forEach(name => {
                                                    const player = findPlayerByName(name);
                                                    if (player) player.playCount++;
                                                });
                                            }
                                        }
                                    });
                                    round.resting.forEach(name => {
                                        const player = findPlayerByName(name);
                                        if (player) player.restCount++;
                                    });
                                });
                                calculatePlayerStats();
                                renderSchedule(parseInt(numCourtsInput.value));
                                showTab('schedule');
                                scheduleLoaded = true;
                                
                             } catch (e) {
                                console.error('Failed to parse schedule from URL:', e);
                             }
                        }

                        if (!scheduleLoaded) {
                            // If no schedule was in the URL (or it failed to parse), generate a new one
                            generateAndDisplaySchedule();
                        }

                    } catch (e) {
                        console.error('Failed to parse players from URL:', e);
                        // Fallback to empty state if parsing fails
                        resetApplicationState();
                    }
                } else {
                    // No URL parameters, start fresh
                    resetApplicationState();
                }
            };
            
            // Add an event listener for score input blur to update the schedule and stats
            scheduleTableBody.addEventListener('blur', (e) => {
                const target = e.target;
                if (target.classList.contains('score-input')) {
                    const courtCell = target.closest('.court-cell');
                    if (courtCell) {
                        const roundIndex = parseInt(courtCell.dataset.roundIndex);
                        const courtIndex = parseInt(courtCell.dataset.courtIndex);
                        const inputs = courtCell.querySelectorAll('.score-input');
                        const scoreA = parseInt(inputs[0].value) || 0;
                        const scoreB = parseInt(inputs[1].value) || 0;
                        const played = scoreA > 0 || scoreB > 0;
                        
                        scheduleData[roundIndex].courts[courtIndex][2] = played; // Update played status
                        scheduleData[roundIndex].courts[courtIndex][3] = scoreA; // Update scoreA
                        scheduleData[roundIndex].courts[courtIndex][4] = scoreB; // Update scoreB

                        if (played) {
                            courtCell.classList.add('played');
                        } else {
                            courtCell.classList.remove('played');
                        }

                        calculatePlayerStats();
                        updateUrlWithCurrentState();
                    }
                }
            }, true);
            
            // Set up event listeners
            generateScheduleBtn.addEventListener('click', generateAndDisplaySchedule);
            resetBtn.addEventListener('click', resetApplicationState);
            randomPlayersBtn.addEventListener('click', generateRandomPlayers);
            
            // Add a click listener for the new "Copy URL" button
            copyUrlBtn.addEventListener('click', () => {
                shareUrlInput.select();
                navigator.clipboard.writeText(shareUrlInput.value)
                    .then(() => {
                        // Show the notification popup
                        const popup = document.getElementById('notificationPopup');
                        popup.classList.remove('opacity-0', 'translate-y-full');
                        popup.classList.add('opacity-100', 'translate-y-0');

                        setTimeout(() => {
                            popup.classList.remove('opacity-100', 'translate-y-0');
                            popup.classList.add('opacity-0', 'translate-y-full');
                        }, 5000);
                    })
                    .catch(err => {
                        console.error('Failed to copy text: ', err);
                    });
            });

            // Initial call to load state from URL or use defaults
            loadStateFromUrl();
        });
    </script>

</body>
</html>
